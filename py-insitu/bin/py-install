#!/bin/bash

# Created by argbash-init v2.10.0
# DEFINE_SCRIPT_DIR([])
# ARG_OPTIONAL_BOOLEAN([rebuild-script])
# ARG_OPTIONAL_BOOLEAN([info])
# ARG_OPTIONAL_BOOLEAN([make])
# ARG_OPTIONAL_BOOLEAN([download])
# ARG_OPTIONAL_BOOLEAN([install])
# ARG_OPTIONAL_BOOLEAN([install-env])
# ARG_OPTIONAL_BOOLEAN([dry-run])
# ARG_HELP([<The general help message of my script>])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='h'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_rebuild_script="off"
_arg_info="off"
_arg_make="off"
_arg_download="off"
_arg_install="off"
_arg_install_env="off"
_arg_dry_run="off"


print_help()
{
	printf '%s\n' "<The general help message of my script>"
	printf 'Usage: %s [--(no-)rebuild-script] [--(no-)info] [--(no-)make] [--(no-)download] [--(no-)install] [--(no-)install-env] [--(no-)dry-run] [-h|--help]\n' "$0"
	printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			--no-rebuild-script|--rebuild-script)
				_arg_rebuild_script="on"
				test "${1:0:5}" = "--no-" && _arg_rebuild_script="off"
				;;
			--no-info|--info)
				_arg_info="on"
				test "${1:0:5}" = "--no-" && _arg_info="off"
				;;
			--no-make|--make)
				_arg_make="on"
				test "${1:0:5}" = "--no-" && _arg_make="off"
				;;
			--no-download|--download)
				_arg_download="on"
				test "${1:0:5}" = "--no-" && _arg_download="off"
				;;
			--no-install|--install)
				_arg_install="on"
				test "${1:0:5}" = "--no-" && _arg_install="off"
				;;
			--no-install-env|--install-env)
				_arg_install_env="on"
				test "${1:0:5}" = "--no-" && _arg_install_env="off"
				;;
			--no-dry-run|--dry-run)
				_arg_dry_run="on"
				test "${1:0:5}" = "--no-" && _arg_dry_run="off"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
				;;
		esac
		shift
	done
}

parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)" || { echo "Couldn't determine the script's running directory, which probably matters, bailing out" >&2; exit 2; }

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


# shellcheck disable=2154
source "$script_dir/paths.sh"

# shellcheck disable=2154
info=$_arg_info

# shellcheck disable=2154
rebuild_script=$_arg_rebuild_script

# shellcheck disable=2154
dryrun=$_arg_dry_run

# shellcheck disable=2154
download=$_arg_download

# shellcheck disable=2154
arg_make=$_arg_make

# shellcheck disable=2154
install=$_arg_install

# shellcheck disable=2154
install_env=$_arg_install_env


doit() {
    local cmds=("$@")
    if [ "$dryrun" = on ]; then
        echo "dry> ${cmds[*]}"
    else
        echo "run> ${cmds[*]}"
        "${cmds[@]}"
    fi

    echo ""
}

with_dirs() {
    local dirnames=("$@")
    for d in "${dirnames[@]}"; do
        if [ ! -d "$d" ]; then
            echo "could not cd to '$d' in ${dirnames[*]}"
            exit 1
        fi
        cd "$d" || exit 1
    done
    echo "In dir: $(pwd)"
}

do_rebuild_script() {
    echo "Rebuilding script.."
    with_dirs "$script_dir"
    argbash py-install.m4 -o py-install
    exit 0
}

download_python() {
    echo "Download Python $PYVER"
    with_dirs "$INSTALL_TMPD"
    if [ ! -f "$PYTGZ" ]; then
        echo "No $PYTGZ found, downloading"
        doit wget "$PYSRC_URL"
    fi
    if [ ! -f "$PYTGZ" ]; then
        echo "Could not download Python from $PYSRC_URL"
        exit 1
    fi
    if [ -f "$PYTGZ" ]; then
        echo "$PYTGZ downloaded"
    fi
}

unpack_python() {
    echo "Unpacking Python $PYVER"
    with_dirs "$INSTALL_TMPD"
    if [ ! -d "$PYSRC" ]; then
        echo "Unpacking $PYTGZ => $PYSRC"
        doit tar -zxf "$PYTGZ"
    else
        echo "$PYSRC exists"
    fi

    if [ ! -d "$PYSRC" ]; then
        echo "Error unpacking $PYSRC"
        exit
    else
        echo "Unpacked Python $PYSRC"
    fi
}

make_python() {
    echo "Making Python $PYVER"
    with_dirs "$INSTALL_TMPD" "$PYSRC"
    doit ./configure --prefix="$PYTHOND" --enable-optimizations --with-lto --enable-loadable-sqlite-extensions

    doit make clean
    doit make build_all
}

install_python() {
    with_dirs "$INSTALL_TMPD" "$PYSRC"
    echo "Making Python $PYVER"
    cd "$INSTALL_TMPD" || exit
    cd "$PYSRC" || exit

    doit rm -rf "$PYTHOND"
    doit mkdir -p "$PYTHOND"
    doit make install
    doit "$PYTHOND/bin/pip3" install --ignore-installed virtualenv
}

install_env() {
    with_dirs "$PROJECT_ROOT"
    echo "Deleting python envs $PYENVS/*"
    doit rm -rf "$PYENVS"
    doit mkdir -p "$PYENVS"
    doit "$PYTHOND/bin/virtualenv" "$ENV_ROOT"
}

test "$info" = on && show_paths && exit 0
test "$rebuild_script" = on && do_rebuild_script && exit 0

if [ "$download" = on ]; then
    echo "Downloading Python"
    download_python
    unpack_python
fi

if [ "$arg_make" = on ]; then
    echo "Making Python"
    make_python
fi

if [ "$install" = on ]; then
    echo "Installing Python"
    install_python
fi

if [ "$install_env" = on ]; then
    echo "(Re)installing Env"
    install_env
fi


# ] <-- needed because of Argbash
